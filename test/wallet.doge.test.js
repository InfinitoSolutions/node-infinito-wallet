const Assert = require('assert');
const chai = require('chai');
const { Wallet, CoinType, InfinitoApi } = require('../index');
const ConfigTest = require('./config.test');
chai.should();

let apiConfigMainnet = {
  apiKey: ConfigTest.API_KEY_MAINNET,
  secret: ConfigTest.SECRECT_MAINNET,
  baseUrl: ConfigTest.BASE_URL_MAINNET,
  logLevel: ConfigTest.LOG_LEVEL
};

let apiConfigTestnet = {
  apiKey: ConfigTest.API_KEY_TESTNET,
  secret: ConfigTest.SECRECT_TESTNET,
  baseUrl: ConfigTest.BASE_URL_TESTNET,
  logLevel: ConfigTest.LOG_LEVEL
};

function getApi(isTestnet = true) {
  if (isTestnet) {
    return new InfinitoApi(apiConfigTestnet);
  }
  return new InfinitoApi(apiConfigMainnet);
}

describe('wallet.DOGE', async() => {
  describe('#constructor()', async() => {
    it('No Parameter', async() => {
      try {
        new Wallet();
        Assert.fail();
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.invalid_cointype');
      }
    });
    it('Default cointype', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        mnemonic: 'still okay stairs fruit pizza mushroom eye cradle seven speak sudden motion'
      });

      Assert.equal('DOGE', wallet.account.coinType);
      Assert.equal('0274a803495befaa68e8cd5a6f92508975141cbd4591500a7e737809da0b533db8', wallet.account.publicKey);
      Assert.equal('DTopHxHUeqgr2U4z3rZ1b8KUAS362mvXj9', wallet.account.address);
    });
  });

  describe('#getAddress()', async() => {
    it('Mnemonic.Mainnet', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        mnemonic: 'toss true onion like penalty spot cloth need disease start coyote suggest'
      });

      Assert.equal(wallet.getAddress(), 'DC7EtZ4fo9ig1siGKv8xYa5MQ7xeCULaYY', 'Address must be right');
    });

    it('Mnemonic.Testnet', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        mnemonic: 'toss true onion like penalty spot cloth need disease start coyote suggest',
        isTestNet: true
      });

      Assert.equal(wallet.getAddress(), 'nm9JDJAkipDikWbsev1y8AUVoaXdkjx4Fx', 'Address must be right');
    });

    it('PrivateKey.Mainnet', async() => {
      const keymaps = [ //generated by https://iancoleman.io/bip39/
        //Mnemonic: ski trick deputy wrist cloud tissue army essence maze usage pipe market
        ["m/44'/3'/0'/0/0",'D66aVXznd3ZiC2nzvmQocm1HtdMnyiCppB','02685ce9112cf2253adb58be57a55957b7d3734e419b2c5c37609bd09eebe5d06b','QR85w7DEcasqupe8GjD6E97LVsH2MYTKhaEzsZ4jxEWrAa37MgqA'],
        ["m/44'/3'/0'/0/1",'DP4ySiQdJXSaKdisW3EHrKypXJ94Jp2TPm','0301e45e8dd306bcfe18bbf950ef8ca87deff2bf9a47dea0b5440f6fddc09d5c82','QQQvhYdWC8L6QEYEVhFu7sco7PkKonqvivQAjprfaDyRbw4hTtde'],
        ["m/44'/3'/0'/0/2",'DDm5cKxpDSNKxNviJaDdEEL15tyS3UBt1o','03cf155fa8c9e5643249e88b0fab8adfedbef373d6d73e15700ec99d53f8901ce9','QSoTqSLsTAmgYNYKvCnvijraxVHh6oK1A1dDugcdM5YAihs7Rg8o'],
        ["m/44'/3'/0'/0/3",'DKvh8qVhDsMKnBwtLZW358cL5N7MukaCQn','029bc30a7c5ba24d38bbb9f6c89ceafcc69a20514d261bee622f4b267934a05dc4','QUXXcLmzh7eSTPxhprUruYp4fwSjxYsNKEPXw1vTetdsoeVo8Di8'],
        ["m/44'/3'/0'/0/4",'DDZn7XVVer1QdGr8cE1Hd1tN6n78t1o8xg','02dc2d6bbd99b2b62967a0253e9eb78ed1a184a8abb21c1f0b84f0c8f5bca430f5','QPpyzg1QLzQdi7K3ZViLVQt7uV45QXCmUHVSceErhHbMLr9YcaV1'],
        ["m/44'/3'/0'/0/5",'DJzPhGNcZVEE4YjXLdweGGta8rzuKJUHF4','02ac1ccf5d03ea14fa237603f85516c162ffc648ec89218fd67d3a35fa19c59469','QXAY5KnhGSg1cmxWBaxSeVTors6ySN7ddVH6Prjgfq7K46wyx3vb'],
        ["m/44'/3'/0'/0/6",'D8pBypvbPMaAdCWhepYCVUB2qLnV2wNHkF','03494d49486e004fcc88cbbccc5b571b03fea47b6fe35f429339452412ad2eaeec','QUpX1qhwd3k9CZnDto7Go8YtS8jthiUH4MQPchHe15L4vBGu393F'],
        ["m/44'/3'/0'/0/7",'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo','037e7bb3ad9ee4b21e4153224ac567131915e668db674a3aa010a250b4a1dfcdad','QTSMQ8ib3rVX1NakiNm9W4q5gx49ovi7rSzRYbe3xEgNizirKdFX'],
        ["m/44'/3'/0'/0/8",'DTZMs4sie25GdbhWGdAnSeEaAENFWfKqUj','03d51a90911d52cc03cb51969d906120e248d690e787099cdc7f09d9e182754db6','QWkWkSfAHegznNMTFh5qU1CMxfYvuwYGaDqmA4VQt4euQbgkfhqQ'],
        ["m/44'/3'/0'/0/9",'DUNBwtvJz2YoV1UD4vdFSzaosTJwE4ASJj','02b1aeb2c2ff1634ced67d19ddf47b6a618cd5109e1756c031c2afc1a74bf284e0','QPhkjC8TYj1BxMkHCiULjNvrVsWH9YDpiDrXZjk1QiY3MAo2a1aj'],
        ["m/44'/3'/0'/0/10",'DFF5Zdig6MC3v8REqR1ZqZQbiezRUMqLJd','0267f4f290fc21b84aa221c4d72a46d660a2d62676c0e11b4b36dbb73e39c7d368','QUbo88mgFQuxdP5iSaVAKwXXkCTRfHp79tJZvDaxYbouTtmnjJnn'],
        ["m/44'/3'/0'/0/11",'DRZZR9UBZoxv4Z7YsX65PA7d93d7PfJvRo','03f109aaf09bf205077a23b6bcdc6cbfa1b191f10a15bea4c4f3878146d38395bb','QVNimZxggnQLbjxdWn2rEV8Y5djzZhQjRdMSWNXX1iHYikJovMdj'],
        ["m/44'/3'/0'/0/12",'D9U5zFYJ2Qt1GCoFDdLHjXwCpG6vk7ugWd','030251f76af59db593a9f35ef97cb18050b54a88c31b937320f716a9612f27ca2f','QP7aCvmKPBCAYXgSsAfJAhV1XiZRYbHmi5TQyZGTYPTEohRxc3iS'],
        ["m/44'/3'/0'/0/13",'DA39Q9Kvn3tdY2NWvK824QVmzZ7WVXAuVG','0277697df5346834738a842aace92d3a99e092f14954b27d144a78b053d17d1ac5','QUXm2Vx6NFxCGu7R56H3oFf8JQmpSSezjhBPQKT9AP8wJ7qszXsq'],
        ["m/44'/3'/0'/0/14",'DLFhaPs4owu77g6mwUTamd4o2NLUhezkJo','020cd253c28512d4cc8de458d6edc165d38ab74ba7afca1771cf1182357ce6c0d3','QNhi5U8xxw8jkXUkj6dV99inirKyVVMVnhTugjd5vEUvMTDtn8Q4'],
        ["m/44'/3'/0'/0/15",'DPcqev6KwmSfBJY1QGuAd63prb3zoypG4a','029e49489ceddb5a31c8959a163613fcbdab5fe3b651dd480daf9c0186453f3cb4','QVPgMFGE2nYywfySxoZwtmdufHajJHmnHnJUbeLRskn8gGudnuX7'],
        ["m/44'/3'/0'/0/16",'DKDA6UFzWTPby3bdHZj6eAwuCC7BRyGgd8','03115f78be3279449ea4654bf77b17adfecf791cfe05e6ecc87b0a43ddb5bb6918','QRAr7Xjeb7jtLrnn28id1aDbL63CdTz83uyEQPewa6LF7yFFHtXT'],
        ["m/44'/3'/0'/0/17",'DE8vrjewGPaHUPZeiGeWZnEd96GckvCLqD','02f96989ec9313b1241034f0783bec8a6ab2e267b9491db4af52f9973f3bb9ce5a','QQho24p4p4Z7sTrjJufTmYTt4G5jZTgvLB3bpFvf1H8n52bpU9y3'],
        ["m/44'/3'/0'/0/18",'DHwqX61u9Rm78XyE3cyiA3uJczfxa7xVZB','026ce0f3b153ac9cd371525527f9a1975951828cc3baaba538b724d70399a1551b','QTHWLqSrGZrLztAoEaLtKDTu5ikL87GLPE6UF3M2riaSrTY8fsMH'],
        ["m/44'/3'/0'/0/19",'DEfYBeAthSRAaW7DHh8ntShUbaqyKvG99c','0206d32291fdc1a08d9b2bbb1002af60cd569b8cf48a2175a5714883c3d7cb15d5','QRWPrbGS2no38ApM45YcAVaaMyRH7FatUd3of3F23pwMGTdVQcHn']            
      ];

      keymaps.forEach((keymap) => {
        let wallet = new Wallet({
          coinType: CoinType.DOGE.symbol,
          privateKey: keymap[3]
        });

        Assert.equal(wallet.getAddress(), keymap[1], `Address must be right. ${JSON.stringify(keymap)}`);
      });
    });

    it('PrivateKey.Testnet', async() => {
      const keymaps = [ //generated by https://walletgenerator.net/?currency=Dogecoin#
        ['nZcsGCZrnB4WCnX2YVV5iyogr63a5pEJ2v','6JKE1HDDxPvcLCxvbiZM4JNe2sTcHCvjzjo72Krsj71k3EchyNd'],
        ['nVtq1EfxcT9XQkE8N4dxdsmCaSCdXdVZqb','6Jneg9ttU3V87GykkF7TEsGxXrmFuTHTE9A8oAEC1JHxgDQpDVZ'],
        ['nqdeNTboMPSN29FkmbXXEBa97Ur34N93x3','6JPEPbbsw56YkvCnq3YFCULxoH6iGfcaypW1ku75XdZpGX8hvfJ'],
        ['npS5bhtqv6xf1CEtkKMX8tjWCeG68RHCu7','6JGA6qwSeCF2nJVzfim1mSrR4erK6b8EPmTMS5brkJxEANDxAKM'],
        ['ndW4B8MFJGQUEj5FutAADKviG7NGqa26UQ','6JLYwDUAnXDpZGV2amU46uzqbKvfVmxTgV78pRkhWZw1PK9Pv7V'],
        ['nkhmET9YRNxcfDZedju1ejT4gwdYCyo1yV','6JxME6FiKw3AXLUSHshcm2U9GcQp3GkNCsixc9Hd5kqvA7HAFVU'],
        ['ns8b9UCXFLDTY9EVK5MNAr11Tu6kUtYE3L','6JYwk1Q3t8nXhvLEHKxLwDbJub6FnDGn5dLBMqkrqfT9nwN8gvD'],
        ['nj6Zbzyiie8fGR4au3sRQdG1GTmQwwsWmX','6Jpr6Coa1XMXHHskSTA5AuoaYurGHzEgUgcZpDmbLTrg3BzfZFf'],
        ['nng9n5zfoP1WxYQXLmuQUR74WS6CSsuq1C','6K5sABRqg9cksPWqXKTJ6M6gsJR1YAXZGWMmqoKxxhKBpZeoCay'],
        ['nqj7AgXVzyt2NHQkrh7TxQnUxGWrLVeupH','6JgtWs43v7nspnAJfKQzdsMSz8dvaDdYCmAAUV2SmsGFsWxosrD']       
      ];

      keymaps.forEach((keymap) => {
        let wallet = new Wallet({
          coinType: CoinType.DOGE.symbol,
          privateKey: keymap[1],
          isTestNet: true
        });

        Assert.equal(wallet.getAddress(), keymap[0], `Address must be right. ${JSON.stringify(keymap)}`);
      });
    });
  });

  describe('#getBalance()', async() => {
    it('Mnemonic.Mainnet', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        mnemonic: ConfigTest.MNEMONIC,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getBalance();
      Assert.ok(result.balance !== undefined, 'Balance must be exist');
      Assert.ok(result.unconfirmed_balance !== undefined, 'Unconfirmed balance must be exist');
    });

  //   it('PrivateKey.Testnet', async() => {
  //     let wallet = new Wallet({
  //       coinType: CoinType.DOGE.symbol,
  //       privateKey: ConfigTest.PRIVATE_KEY_DOGE,
  //       isTestNet: true
  //     });

  //     wallet.setApi(getApi(true));
  //     let address = await wallet.getAddress();
  //     console.log("address = ", address);
  //     let result = await wallet.getBalance();
  //     Assert.ok(result.balance > 0, 'Balance must be exist');
  //     Assert.ok(result.unconfirmed_balance !== undefined, 'Unconfirmed balance must be exist');
  //   });
  });

  describe('#getHistory()', async() => {
    it('default', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        mnemonic: ConfigTest.MNEMONIC,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getHistory();
      Assert.ok(result.txs.length >= 0, 'History must be exist');
    });

    it('offset.limit', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        mnemonic: ConfigTest.MNEMONIC,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getHistory(0, 1);
      Assert.ok(result.txs.length == 1, 'History must have one item');
    });

    it('offset = 50', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        mnemonic: ConfigTest.MNEMONIC,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getHistory(50, 50);
      Assert.ok(result.txs.length == 0, 'History must be empty');
    });
  });

  describe('#getDefaultFee()', async() => {
    it('default', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getDefaultFee();
      Assert.ok(result > 0);
    });
    it('high', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getDefaultFee('high');
      Assert.ok(result > 0);
    });
    it('medium', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getDefaultFee('medium');
      Assert.ok(result > 0);
    });
    it('low', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let result = await wallet.getDefaultFee('low');
      Assert.ok(result > 0);
    });
    it('error', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let api = wallet.getApi();
      api.DOGE.getFeeRate = function() {
        return { cd: 1 };
      };
      try {
        await wallet.getDefaultFee('low');
        Assert.fail();
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.internal_error');
      }
    });
  });

  describe('#createRawTx()', async() => {
    it('Missing parameter to', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });

      try {
        await wallet.createRawTx({});
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.missing_parameter');
        Assert.equal(err.message, 'Missing required parameter to');
      }
    });

    it('Missing parameter fee', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });

      try {
        await wallet.createRawTx({
          to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo'
        });
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.missing_parameter');
        Assert.equal(err.message, 'Missing required parameter fee or feeType');
      }
    });

    it('Invalid feeType', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });

      try {
        await wallet.createRawTx({
          to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo',
          feeType: 'InValid'
        });
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.invalid_parameter');
        Assert.equal(err.message, 'Parameter is invalid. (feeType)');
      }
    });

    it('Invalid fee', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });

      try {
        await wallet.createRawTx({
          to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo',
          fee: 'InValid'
        });
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.invalid_parameter');
        Assert.equal(err.message, 'Parameter is invalid. (fee)');
      }
    });

    it('fee = 0', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });

      try {
        await wallet.createRawTx({
          to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo',
          fee: 0
        });
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.invalid_parameter');
        Assert.equal(err.message, 'Parameter is invalid. (fee)');
      }
    });

    it('fee < 0', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });

      try {
        await wallet.createRawTx({
          to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo',
          fee: -1
        });
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.invalid_parameter');
        Assert.equal(err.message, 'Parameter is invalid. (fee)');
      }
    });

    // it('default', async() => {

    //   let wallet = new Wallet({
    //     coinType: CoinType.DOGE.symbol,
    //     privateKey: ConfigTest.PRIVATE_KEY_DOGE,
    //     isTestNet: true
    //   });
    //   wallet.setApi(getApi(true));
    //   let listUnspent = [{
    //       'tx_id': '1e13afb2b3c1afcd7751298cd72af6d68a90eb1c018990f483f3f1bbf61c09e8',
    //       'vout': 0,
    //       'scriptpubkey': '76a914cb6fdab1832fc8be8eef0a0f11c12e53563e4c4688ac',
    //       'confirmations': 606,
    //       'amount': 9000
    //     }];
    //   let createResult = await wallet.createRawTx({
    //     to: 'yYHM58vCYL6aAxFgnNhbWkQyYEvU8CX3XK',
    //     fee: 5,
    //     amount: 1000,
    //     listUnspent
    //   });

    //   Assert.ok(createResult.fee > 0, 'Fee must be right');
    //   Assert.ok(createResult.tx_id.length > 0, 'Tx id must be right');
    //   Assert.ok(createResult.raw.length > 0, 'Raw must be right');
    // });

    // it('feeType = high', async() => {
    //   let wallet = new Wallet({
    //     coinType: CoinType.DOGE.symbol,
    //     privateKey: ConfigTest.PRIVATE_KEY_DOGE,
    //     isTestNet: true
    //   });
    //   wallet.setApi(getApi(true));
    //   let listUnspent = [{
    //       'tx_id': '1e13afb2b3c1afcd7751298cd72af6d68a90eb1c018990f483f3f1bbf61c09e8',
    //       'vout': 0,
    //       'scriptpubkey': '76a914cb6fdab1832fc8be8eef0a0f11c12e53563e4c4688ac',
    //       'confirmations': 606,
    //       'amount': 9000
    //     }];
    //   let createResult = await wallet.createRawTx({
    //     to: 'yYHM58vCYL6aAxFgnNhbWkQyYEvU8CX3XK',
    //     feeType: 'high',
    //     amount: 1000,
    //     listUnspent
    //   });

    //   Assert.ok(createResult.fee > 0, 'Fee must be right');
    //   Assert.ok(createResult.tx_id.length > 0, 'Tx id must be right');
    //   Assert.ok(createResult.raw.length > 0, 'Raw must be right');
    // });

    it('OVER_BALANCE', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      let createResult = await wallet.createRawTx({
        to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo',
        fee: 5,
        amount: 10000000
      });

      Assert.equal(createResult.error, 'OVER_BALANCE');
    });

    it('Fail to get utxo', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      let api = getApi(false);
      wallet.setApi(api);
      api.DOGE.getUtxo = function() {
        return { cd: 1 };
      };
      try {
        await wallet.createRawTx({
          to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo',
          fee: 5,
          amount: 100000
        });
        Assert.fail();
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.can_not_get_utxo');
        Assert.equal(err.message, "Can't get utxo.");
      }
    });
  });

  describe('#send()', async() => {
    it('send invalid raw transaction', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));

      let rawTx = '100000001e8091cf6bbf1f383f49089011ceb908ad6f62ad78c295177cdafc1b3b2af131e0000000000ffffffff02e8030000000000001976a914f65f9ef810028c9e642ed1f149a254fa020be86c88ac40130000000000001976a9146273d8f8c8c41f3980adbc15b7a5509eb38372d288ac00000000';
      try {
        await wallet.send({ rawTx });
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.send_transaction_fail');
        Assert.ok(err.message.indexOf('decode hex') > 0);
      }
    });

    it('No rawTx & txParam', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));

      try {
        await wallet.send({});
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.missing_parameter');
        Assert.equal(err.message, 'Missing required parameter rawTx or txParams');
      }
    });

    it('fail to create raw', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));
      try {
        await wallet.send({
          txParams: {
            to: 'DSw7iFEikmHytnCZaJC9tzz3EQGarC6LZo',
            fee: 5,
            amount: 1000000000
          }
        });
        Assert.fail();
      } catch (err) {
        Assert.equal(err.code, 'infinito.wallet.create_rawtx_fail');
        Assert.equal(err.message, 'Fail when create raw transaction');
      }
    });

    // it('broadcast with custom fee', async() => {
    //   let wallet = new Wallet({
    //     coinType: CoinType.DOGE.symbol,
    //     privateKey: ConfigTest.PRIVATE_KEY_DOGE,
    //     isTestNet: true
    //   });
    //   wallet.setApi(getApi(true));
    //   let sendResult = await wallet.send({
    //     txParams: {
    //       to: 'LL4CcubAydhUmh2M8cKi78vbNZbSa774v3',
    //       fee: 5,
    //       amount: 1
    //     }
    //   });

    //   sendResult.should.have.property('tx_id');
    //   Assert.ok(sendResult.tx_id.length > 0);
    // });

    it('do not broadcast', async() => {
      let wallet = new Wallet({
        coinType: CoinType.DOGE.symbol,
        privateKey: ConfigTest.PRIVATE_KEY_DOGE,
        isTestNet: false
      });
      wallet.setApi(getApi(false));

      let rawTx = '0200000001da8c213e9cede4f75ad5c9023d7871781aa36102bf4bd12d59d004c26172c6cc000000006b483045022100ee0a66581681c105db89a89e0341e25b3708ffed3cd54a4fe7e51e4f4cc850280220741d37eea40c9064676cbb034611e36198f4281b2131f05984592cf2451225010121025cdbb5e871e74b2749388e1534f441d5d39a64bed8d1909315bde3bbee0cb138feffffff01e0a54b00000000001976a91441fd36eef3a1bcdb94dead1a24650d9e7f31e90a88ac00000000';
      let result = await wallet.send({ rawTx, isBroadCast: false });
      Assert.ok(result.raw.length > 0);
    });
  });

});